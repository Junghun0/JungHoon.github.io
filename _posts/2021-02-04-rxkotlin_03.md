---
layout: post
title: "[Kotlin] RxKotlin Study 03"
subtitle: 'Reactive Prgramming in Kotlin'
author: "JungHoon-Park"
header-style: text
header-mask: 0.3
comments: true
catalog:  true
tags:
  - Android
  - Kotlin
  - Study
  - RxKotlin
  - Reactive Programming
---

RxKotlin 공부하기

---

## 옵저버블과 옵저버와 구독자

### Observable

`Observable`은 그 컨슈머(`Observer`)가 소비할 수 있는 값을 산출해 내는 기본 계산 작업을 갖고 있다. 여기서 가장 중요한 것은 컨슈머(`Observer`)가 값을 `pull` 방식을 사용해 접근하지 않는다는 점이다. 오히려 옵저버블은 컨슈머에게 값을 `push` 하는 역할을 한다. 순차적으로 이해해보면<br/>
- 옵저버는 옵저버블을 구독한다.
- 옵저버블이 그 내부의 아이템들을 내보내기 시작한다.
- 옵저버는 옵저버블에서 내보내는 모든 아이템에 반응한다.<br/>

### Observable 이 동작하는 방법
- onNext : 옵저버블은 모든 아이템을 하나씩 이 메서드에 전달한다.
- onComplete : 모든 아이템이 `onNext` 메서드를 통과하면 옵저버블은 `onComplete` 메서드를 호출한다.
- onError : 옵저버블에서 에러가 발생하면 `onError` 메서드가 호출돼 정의된 대로 에러를 처리한다. `onError` 와 `onComplete`는 터미널 이벤트이다. `onError`가 호출됐을 때 `onComplete`가 호출되지 않으며, 반대의 경우도 마찬가지다.<br/>
예제를 보자<br/>
[ 예제 ]<br/>
~~~java
fun main() {
    val observer: Observer<Any> = object: Observer<Any> { // 1
        override fun onComplete() { // 2
            println("All Completed")
        }

        override fun onNext(item: Any) {// 3
            println("Next $item")
        }

        override fun onError(e: Throwable) {// 4
            println("Subscribed to $e")
        }

        override fun onSubscribe(d: Disposable) {// 5
            println("Subscribed to $d")
        }
    }

    val observable: Observable<Any> = listOf("One", 2, "Three", "Four", 4.5, "Five", 6.0f).toObservable() // 6

    observable.subscribe(observer)// 7

    val observableOnList: Observable<List<Any>> = Observable.just(
        listOf("One", 2, "Three", "Four", 4.5, "Five", 6.0f),
        listOf("List with Single Item"),
        listOf(1,2,3,4,5,6) 
    ) // 8
    
    observableOnList.subscribe(observer)// 9
}
~~~
- 1,2 -> `onComplete()` 메서드는 `Observable`이 오류 없이 모든 아이템을 처리하면 호출된다.<br/>
- 3 -> `onNext(item: Any)`함수를 정의했으며 이 함수는 옵저버블이 내보내는 각 아이템에 대해 호출된다.<br/>
- 4 -> 옵저버블에 오류가 발생했을 때 호출된다.<br/>
- 5 -> 옵저버가 옵저버블을 구독할 때마다 호출된다.<br/>
- 6 -> 옵저버블을 생성하고<br/>
- 7 -> `observer`가 `observable`을 구독한다.<br/>
<br/>

## Observable.create()

언제든지 Observable.create 메서드로 옵저버블을 직접 생성할 수 있다. 이 메서드는 관찰 대상자를 `ObservableEmitter<T>` 인터페이스의 인스턴스를 입력받는다.<br/>
[ 예제 ]<br/>
~~~java
fun main() {
    val observer: Observer<String> = object: Observer<String> {
        override fun onComplete() {
            println("All Completed")
        }

        override fun onNext() {
            println("Next $item")
        }

        override fun onError(e: Throwable) {
            println("Error Occured #{e.message}")
        }

        override fun onSubscribed(d: Disposable) {
            println("New Subscribe")
        }
    } // Observer 생성

    val observable: Observable<String> = Observable.create<String> { // 1
        it.onNext("Emit 1")
        it.onNext("Emit 2")
        it.onNext("Emit 3")
        it.onNext("Emit 4")
        it.onComplete()
    }

    observable.subscrbie(observer)

    val observable2: Observable<String> = Observable.create<String> { // 2
        it.onNext("Emit 1")
        it.onNext("Emit 2")
        it.onNext("Emit 3")
        it.onNext("Emit 4")
        it.onError(Exception("My Custom Exception"))
    }

    observable2.subscrbie(observer)
}
~~~ 
- 1 -> `Observable.create` 메서드로 옵저버블을 생성했다. `onNext` 메서드로 4개의 문자열을 내보낸 후 다음 `onComplete` 메서드로 완료되었음을 알려준다. <br/>
- 2 -> `onComplete`를 호출하는 대신 사용자 정의된 `Exception`으로 `onError`를 호출한다.<br/>

**Observable.create** 메서드는 특히 사용자가 지정한 데이터 구조를 사용하거나 내보내는 값을 제어하려고 할 때 유용하다. 다른 스레드에서 옵저버로 값을 내보낼 수도 있다.

## Observable.from()

`Observable.from` 메서드는 `Observable.create` 메서드에 비해 상대적으로 간단하다.
`from` 메서드의 도움을 받아 거의 모든 코틀린 구조체로부터 `Observable 인스턴스`를 생성할 수 있다.<br/>
~~~java
fun main() {

    val observer: Observer<String> = object: Observer<String> {

        override fun onComplete() {
            println("All Completed")
        }

        override fun onNext(item: String) {
            println("Next $item")
        }

        override fun onError(e: Throwable) {
            println("Error Occured ${e.message}")
        }

        override fun onSubscribed(d: Disposable) {
            println("New Subscription")
        }
    } // Observer 생성

    val list = listOf("String1", "String2", "String3", "String4")
    val observableFromIterable: Observable<String> = 
    Observable.fromIterable(list) //1
    observableFromIterable.subscribe(observer)

    val observableFromCallable: Observable<String> = 
    Observable.fromCallable(callable)
    observableFromCallable.subscribe(observer)
}
~~~
`Observable.fromIterable` 메서드를 사용해 `Iterable 인스턴스` 로부터 옵저버블을 생성했다.<br/>
`Observable.fromCallable` 메서드를 호출해 `Callable 인스턴스` 에서 옵저버블을 생성했다.<br/>

### toObservable 의 확장 함수의 이해
코틀린의 `확장함수` 덕분에 List 와 같이 어떠한 Iterable 인스턴스도 Observable로 큰 어려움 없이 변경이 가능하다.
